package main

import (
	"fmt"
	"go/format"
	"io"
	"log"
	"os"
	"path/filepath"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"
	"google.golang.org/protobuf/types/pluginpb"
)

func main() {
	input, err := io.ReadAll(os.Stdin)
	if err != nil {
		log.Fatalf("Failed to read input: %v", err)
	}

	var req pluginpb.CodeGeneratorRequest
	if err := proto.Unmarshal(input, &req); err != nil {
		log.Fatalf("Failed to unmarshal request: %v", err)
	}

	resp := generate(&req)
	output, err := proto.Marshal(resp)
	if err != nil {
		log.Fatalf("Failed to marshal response: %v", err)
	}

	if _, err := os.Stdout.Write(output); err != nil {
		log.Fatalf("Failed to write output: %v", err)
	}
}

func generate(req *pluginpb.CodeGeneratorRequest) *pluginpb.CodeGeneratorResponse {
	opts, err := parseOptions(req.GetParameter())
	if err != nil {
		return &pluginpb.CodeGeneratorResponse{
			Error: proto.String(fmt.Sprintf("Failed to parse options: %v", err)),
		}
	}

	gen, err := protogen.Options{}.New(req)
	if err != nil {
		return &pluginpb.CodeGeneratorResponse{
			Error: proto.String(fmt.Sprintf("Failed to create protogen: %v", err)),
		}
	}

	var files []*pluginpb.CodeGeneratorResponse_File

	for _, file := range gen.Files {
		if !file.Generate {
			continue
		}

		generated, err := generateFile(file, opts)
		if err != nil {
			return &pluginpb.CodeGeneratorResponse{
				Error: proto.String(fmt.Sprintf("Failed to generate file %s: %v", file.Desc.Path(), err)),
			}
		}

		if generated != nil {
			files = append(files, generated)
		}
	}

	return &pluginpb.CodeGeneratorResponse{
		File:              files,
		SupportedFeatures: proto.Uint64(uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)),
	}
}

type options struct {
	pathsSourceRelative bool
	module              string
}

func parseOptions(parameter string) (*options, error) {
	opts := &options{}

	if parameter == "" {
		return opts, nil
	}

	for _, param := range strings.Split(parameter, ",") {
		param = strings.TrimSpace(param)
		if param == "" {
			continue
		}

		switch {
		case param == "paths=source_relative":
			opts.pathsSourceRelative = true
		case strings.HasPrefix(param, "module="):
			opts.module = strings.TrimPrefix(param, "module=")
		default:
			return nil, fmt.Errorf("unknown parameter: %s", param)
		}
	}

	return opts, nil
}

func generateFile(file *protogen.File, opts *options) (*pluginpb.CodeGeneratorResponse_File, error) {
	if len(file.Services) == 0 {
		return nil, nil
	}

	filename := file.Desc.Path()
	filename = strings.TrimSuffix(filename, ".proto")

	goPackageOpt := ""
	if file.Desc.Options() != nil {
		if opts := file.Desc.Options().(*descriptorpb.FileOptions); opts != nil {
			goPackageOpt = opts.GetGoPackage()
		}
	}

	packageName := string(file.GoPackageName)
	importPath := string(file.GoImportPath)

	if goPackageOpt != "" {
		if strings.Contains(goPackageOpt, ";") {
			parts := strings.Split(goPackageOpt, ";")
			importPath = parts[0]
			packageName = parts[1]
		} else {
			importPath = goPackageOpt
			packageName = filepath.Base(goPackageOpt)
		}
	}

	if opts.pathsSourceRelative {
		// paths=source_relative: keep the file in the same directory as the source proto
		filename += "_jrpc.pb.go"
	} else {
		// Default: use import path but apply module trimming if specified
		outputPath := importPath

		// Apply module trimming if module option is specified
		if opts.module != "" && strings.HasPrefix(outputPath, opts.module) {
			// Remove module prefix
			if outputPath == opts.module {
				outputPath = ""
			} else if strings.HasPrefix(outputPath, opts.module+"/") {
				outputPath = strings.TrimPrefix(outputPath, opts.module+"/")
			}
		}

		if outputPath != "" {
			importDir := strings.ReplaceAll(outputPath, ".", "/")
			filename = filepath.Join(importDir, filepath.Base(filename)+"_jrpc.pb.go")
		} else {
			filename += "_jrpc.pb.go"
		}
	}

	generator := &fileGenerator{
		file:        file,
		opts:        opts,
		packageName: packageName,
		importPath:  importPath,
	}

	return generator.generate(filename)
}

type fileGenerator struct {
	file        *protogen.File
	opts        *options
	packageName string
	importPath  string
}

func (g *fileGenerator) generate(filename string) (*pluginpb.CodeGeneratorResponse_File, error) {
	var buf strings.Builder

	buf.WriteString("// Code generated by protoc-gen-go-jrpc. DO NOT EDIT.\n")
	buf.WriteString(fmt.Sprintf("// source: %s\n\n", g.file.Desc.Path()))
	buf.WriteString(fmt.Sprintf("package %s\n\n", g.packageName))

	// Collect all imports needed for the service methods
	imports := g.collectImports()

	// Write imports
	buf.WriteString("import (\n")
	buf.WriteString("\t\"context\"\n")
	buf.WriteString("\t\"errors\"\n")
	for alias, path := range imports {
		if alias != "" && alias != filepath.Base(path) {
			buf.WriteString(fmt.Sprintf("\t%s \"%s\"\n", alias, path))
		} else {
			buf.WriteString(fmt.Sprintf("\t\"%s\"\n", path))
		}
	}
	buf.WriteString(")\n\n")

	for _, service := range g.file.Services {
		g.generateService(&buf, service)
	}

	formatted, err := format.Source([]byte(buf.String()))
	if err != nil {
		return nil, fmt.Errorf("failed to format generated code: %v", err)
	}

	return &pluginpb.CodeGeneratorResponse_File{
		Name:    proto.String(filename),
		Content: proto.String(string(formatted)),
	}, nil
}

func (g *fileGenerator) collectImports() map[string]string {
	imports := make(map[string]string)

	for _, service := range g.file.Services {
		for _, method := range service.Methods {
			// Check input type
			if method.Input.GoIdent.GoImportPath != g.file.GoImportPath {
				importPath := string(method.Input.GoIdent.GoImportPath)
				if importPath != "" {
					packageName := filepath.Base(importPath)
					imports[packageName] = importPath
				}
			}

			// Check output type
			if method.Output.GoIdent.GoImportPath != g.file.GoImportPath {
				importPath := string(method.Output.GoIdent.GoImportPath)
				if importPath != "" {
					packageName := filepath.Base(importPath)
					imports[packageName] = importPath
				}
			}
		}
	}

	return imports
}

func (g *fileGenerator) getGoType(message *protogen.Message) string {
	// Check if the message is from a different package
	if message.GoIdent.GoImportPath != g.file.GoImportPath {
		// Use the package name as prefix for external types
		packageName := filepath.Base(string(message.GoIdent.GoImportPath))
		return fmt.Sprintf("%s.%s", packageName, message.GoIdent.GoName)
	}
	// Use protogen's built-in type resolution which properly handles proto3 optional fields
	return string(message.GoIdent.GoName)
}

func (g *fileGenerator) generateService(buf *strings.Builder, service *protogen.Service) {
	serviceName := string(service.Desc.Name())

	// Generate the unimplemented server struct
	buf.WriteString(fmt.Sprintf("type Unimplemented%sServer struct{}\n\n", serviceName))

	// Generate methods for each RPC
	for _, method := range service.Methods {
		g.generateMethod(buf, serviceName, method)
	}
}

func (g *fileGenerator) generateMethod(buf *strings.Builder, serviceName string, method *protogen.Method) {
	methodName := string(method.Desc.Name())
	inputType := g.getGoType(method.Input)
	outputType := g.getGoType(method.Output)

	isClientStreaming := method.Desc.IsStreamingClient()
	isServerStreaming := method.Desc.IsStreamingServer()

	// Determine method signature based on streaming
	var signature, body string

	if !isClientStreaming && !isServerStreaming {
		// Unary
		signature = fmt.Sprintf("func (Unimplemented%sServer) %s(ctx context.Context, in *%s) (*%s, error)",
			serviceName, methodName, inputType, outputType)
		body = g.generateErrorReturn(serviceName, methodName, true)
	} else if isClientStreaming && !isServerStreaming {
		// Client streaming
		signature = fmt.Sprintf("func (Unimplemented%sServer) %s(ctx context.Context, in chan *%s) (*%s, error)",
			serviceName, methodName, inputType, outputType)
		body = g.generateErrorReturn(serviceName, methodName, true)
	} else if !isClientStreaming && isServerStreaming {
		// Server streaming
		signature = fmt.Sprintf("func (Unimplemented%sServer) %s(ctx context.Context, in *%s, out chan %s) error",
			serviceName, methodName, inputType, outputType)
		body = g.generateErrorReturn(serviceName, methodName, false)
	} else {
		// Bidirectional streaming
		signature = fmt.Sprintf("func (Unimplemented%sServer) %s(ctx context.Context, in chan *%s, out chan %s) error",
			serviceName, methodName, inputType, outputType)
		body = g.generateErrorReturn(serviceName, methodName, false)
	}

	buf.WriteString(fmt.Sprintf("%s {\n", signature))
	buf.WriteString(fmt.Sprintf("\t%s\n", body))
	buf.WriteString("}\n\n")
}

func (g *fileGenerator) generateErrorReturn(serviceName, methodName string, needsNilReturn bool) string {
	errorMsg := fmt.Sprintf("method %s.%s not implemented", serviceName, methodName)
	errorCall := fmt.Sprintf("errors.New(\"%s\")", errorMsg)

	if needsNilReturn {
		return fmt.Sprintf("return nil, %s", errorCall)
	} else {
		return fmt.Sprintf("return %s", errorCall)
	}
}
