package main

import (
	"fmt"
	"go/format"
	"io"
	"log"
	"os"
	"path/filepath"
	"strings"

	"github.com/valentin-kaiser/go-core/flag"
	"github.com/valentin-kaiser/go-core/version"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"
	"google.golang.org/protobuf/types/pluginpb"
)

type generator struct {
	file        *protogen.File
	opts        *options
	packageName string
	importPath  string
}

type options struct {
	relative bool
	module   string
}

func main() {
	flag.Unregister("debug")
	flag.Unregister("path")
	flag.Init()

	if flag.Help {
		flag.PrintHelp()
		return
	}

	if flag.Version {
		fmt.Println(version.String())
		return
	}

	input, err := io.ReadAll(os.Stdin)
	if err != nil {
		log.Fatalf("Failed to read input: %v", err)
	}

	var req pluginpb.CodeGeneratorRequest
	err = proto.Unmarshal(input, &req)
	if err != nil {
		log.Fatalf("Failed to unmarshal request: %v", err)
	}

	resp := generate(&req)
	output, err := proto.Marshal(resp)
	if err != nil {
		log.Fatalf("Failed to marshal response: %v", err)
	}

	_, err = os.Stdout.Write(output)
	if err != nil {
		log.Fatalf("Failed to write output: %v", err)
	}
}

func generate(req *pluginpb.CodeGeneratorRequest) *pluginpb.CodeGeneratorResponse {
	opts, err := parseOptions(req.GetParameter())
	if err != nil {
		return &pluginpb.CodeGeneratorResponse{
			Error: proto.String(fmt.Sprintf("Failed to parse options: %v", err)),
		}
	}

	gen, err := protogen.Options{}.New(req)
	if err != nil {
		return &pluginpb.CodeGeneratorResponse{
			Error: proto.String(fmt.Sprintf("Failed to create protogen: %v", err)),
		}
	}

	var files []*pluginpb.CodeGeneratorResponse_File
	for _, file := range gen.Files {
		if !file.Generate {
			continue
		}

		generated, err := generateFile(file, opts)
		if err != nil {
			return &pluginpb.CodeGeneratorResponse{
				Error: proto.String(fmt.Sprintf("Failed to generate file %s: %v", file.Desc.Path(), err)),
			}
		}

		if generated != nil {
			files = append(files, generated)
		}
	}

	return &pluginpb.CodeGeneratorResponse{
		File:              files,
		SupportedFeatures: proto.Uint64(uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)),
	}
}

func parseOptions(parameter string) (*options, error) {
	opts := &options{}

	if parameter == "" {
		return opts, nil
	}

	for _, param := range strings.Split(parameter, ",") {
		param = strings.TrimSpace(param)
		if param == "" {
			continue
		}

		switch {
		case param == "paths=source_relative":
			opts.relative = true
		case strings.HasPrefix(param, "module="):
			opts.module = strings.TrimPrefix(param, "module=")
		default:
			return nil, fmt.Errorf("unknown parameter: %s", param)
		}
	}

	return opts, nil
}

func generateFile(file *protogen.File, opts *options) (*pluginpb.CodeGeneratorResponse_File, error) {
	if len(file.Services) == 0 {
		return nil, nil
	}

	base := strings.TrimSuffix(file.Desc.Path(), ".proto")
	finalFilename := base + "_jrpc.pb.go"

	goPackageOpt := ""
	if file.Desc.Options() != nil {
		if fileOpts := file.Desc.Options().(*descriptorpb.FileOptions); fileOpts != nil {
			goPackageOpt = fileOpts.GetGoPackage()
		}
	}

	packageName := string(file.GoPackageName)
	importPath := string(file.GoImportPath)

	if goPackageOpt != "" {
		importPath = goPackageOpt
		packageName = filepath.Base(goPackageOpt)

		if strings.Contains(goPackageOpt, ";") {
			parts := strings.Split(goPackageOpt, ";")
			importPath = parts[0]
			packageName = parts[1]
		}
	}

	if !opts.relative {
		outputPath := importPath

		if opts.module != "" && strings.HasPrefix(outputPath, opts.module) && outputPath != opts.module {
			outputPath = strings.TrimPrefix(outputPath, opts.module+"/")
		}
		if opts.module != "" && outputPath == opts.module {
			outputPath = ""
		}

		if outputPath != "" {
			importDir := strings.ReplaceAll(outputPath, ".", "/")
			finalFilename = filepath.Join(importDir, filepath.Base(base)+"_jrpc.pb.go")
		}
	}

	generator := &generator{
		file:        file,
		opts:        opts,
		packageName: packageName,
		importPath:  importPath,
	}

	return generator.generate(finalFilename)
}

func (g *generator) generate(filename string) (*pluginpb.CodeGeneratorResponse_File, error) {
	var buf strings.Builder

	buf.WriteString("// Code generated by protoc-gen-go-jrpc. DO NOT EDIT.\n")
	buf.WriteString(fmt.Sprintf("// source: %s\n\n", g.file.Desc.Path()))
	buf.WriteString(fmt.Sprintf("package %s\n\n", g.packageName))

	imports := g.imports()
	buf.WriteString("import (\n")
	buf.WriteString("\t\"context\"\n")
	buf.WriteString("\t\"errors\"\n")
	buf.WriteString("\t\"google.golang.org/protobuf/reflect/protoreflect\"\n")
	buf.WriteString("\t\"github.com/valentin-kaiser/go-core/web/jrpc\"\n")
	for alias, path := range imports {
		if alias != "" && alias != filepath.Base(path) {
			buf.WriteString(fmt.Sprintf("\t%s \"%s\"\n", alias, path))
		} else {
			buf.WriteString(fmt.Sprintf("\t\"%s\"\n", path))
		}
	}
	buf.WriteString(")\n\n")

	for _, service := range g.file.Services {
		g.service(&buf, service)
	}

	formatted, err := format.Source([]byte(buf.String()))
	if err != nil {
		return nil, fmt.Errorf("failed to format generated code: %v", err)
	}

	return &pluginpb.CodeGeneratorResponse_File{
		Name:    proto.String(filename),
		Content: proto.String(string(formatted)),
	}, nil
}

func (g *generator) imports() map[string]string {
	imports := make(map[string]string)

	for _, service := range g.file.Services {
		for _, method := range service.Methods {
			// Check input type
			if method.Input.GoIdent.GoImportPath != g.file.GoImportPath {
				importPath := string(method.Input.GoIdent.GoImportPath)
				if importPath != "" {
					packageName := filepath.Base(importPath)
					imports[packageName] = importPath
				}
			}

			// Check output type
			if method.Output.GoIdent.GoImportPath != g.file.GoImportPath {
				importPath := string(method.Output.GoIdent.GoImportPath)
				if importPath != "" {
					packageName := filepath.Base(importPath)
					imports[packageName] = importPath
				}
			}
		}
	}

	return imports
}

func (g *generator) goType(message *protogen.Message) string {
	// Check if the message is from a different package
	if message.GoIdent.GoImportPath != g.file.GoImportPath {
		// Use the package name as prefix for external types
		packageName := filepath.Base(string(message.GoIdent.GoImportPath))
		return fmt.Sprintf("%s.%s", packageName, message.GoIdent.GoName)
	}
	// Use protogen's built-in type resolution which properly handles proto3 optional fields
	return string(message.GoIdent.GoName)
}

func (g *generator) service(buf *strings.Builder, service *protogen.Service) {
	serviceName := string(service.Desc.Name())

	// Generate the service interface
	g.generateInterface(buf, serviceName, service)

	// Generate the unimplemented server struct
	buf.WriteString(fmt.Sprintf("type Unimplemented%sServer struct{}\n\n", serviceName))

	// Generate Descriptor method
	buf.WriteString(fmt.Sprintf("func (Unimplemented%sServer) Descriptor() protoreflect.FileDescriptor {\n", serviceName))
	buf.WriteString(fmt.Sprintf("\treturn %s\n", fmt.Sprintf("File_%s_proto", strings.TrimSuffix(filepath.Base(g.file.Desc.Path()), ".proto"))))
	buf.WriteString("}\n\n")

	// Generate methods for each RPC
	for _, method := range service.Methods {
		g.method(buf, serviceName, method)
	}

	// Generate registration function
	g.generateRegistrationFunction(buf, serviceName)
}

func (g *generator) method(buf *strings.Builder, serviceName string, method *protogen.Method) {
	methodName := string(method.Desc.Name())
	inputType := g.goType(method.Input)
	outputType := g.goType(method.Output)

	isClientStreaming := method.Desc.IsStreamingClient()
	isServerStreaming := method.Desc.IsStreamingServer()

	// Determine method signature based on streaming
	var signature, body string

	switch {
	case !isClientStreaming && !isServerStreaming:
		// Unary
		signature = fmt.Sprintf("func (Unimplemented%sServer) %s(ctx context.Context, in *%s) (*%s, error)",
			serviceName, methodName, inputType, outputType)
		body = g.errorReturn(serviceName, methodName, true)
	case isClientStreaming && !isServerStreaming:
		// Client streaming
		signature = fmt.Sprintf("func (Unimplemented%sServer) %s(ctx context.Context, in chan *%s) (*%s, error)",
			serviceName, methodName, inputType, outputType)
		body = g.errorReturn(serviceName, methodName, true)
	case !isClientStreaming && isServerStreaming:
		// Server streaming
		signature = fmt.Sprintf("func (Unimplemented%sServer) %s(ctx context.Context, in *%s, out chan *%s) error",
			serviceName, methodName, inputType, outputType)
		body = g.errorReturn(serviceName, methodName, false)
	case isClientStreaming && isServerStreaming:
		// Bidirectional streaming
		signature = fmt.Sprintf("func (Unimplemented%sServer) %s(ctx context.Context, in chan *%s, out chan *%s) error",
			serviceName, methodName, inputType, outputType)
		body = g.errorReturn(serviceName, methodName, false)
	}

	buf.WriteString(fmt.Sprintf("%s {\n", signature))
	buf.WriteString(fmt.Sprintf("\t%s\n", body))
	buf.WriteString("}\n\n")
}

func (g *generator) errorReturn(serviceName, methodName string, needsNilReturn bool) string {
	errorMsg := fmt.Sprintf("method %s.%s not implemented", serviceName, methodName)
	errorCall := fmt.Sprintf("errors.New(\"%s\")", errorMsg)

	if needsNilReturn {
		return fmt.Sprintf("return nil, %s", errorCall)
	} else {
		return fmt.Sprintf("return %s", errorCall)
	}
}

func (g *generator) generateInterface(buf *strings.Builder, serviceName string, service *protogen.Service) {
	buf.WriteString(fmt.Sprintf("// %sServer is the server API for %s service.\n", serviceName, serviceName))
	buf.WriteString(fmt.Sprintf("type %sServer interface {\n", serviceName))

	// Add Descriptor method to interface
	buf.WriteString("\tDescriptor() protoreflect.FileDescriptor\n")

	// Generate interface methods
	for _, method := range service.Methods {
		g.generateInterfaceMethod(buf, method)
	}

	buf.WriteString("}\n\n")
}

func (g *generator) generateInterfaceMethod(buf *strings.Builder, method *protogen.Method) {
	methodName := string(method.Desc.Name())
	inputType := g.goType(method.Input)
	outputType := g.goType(method.Output)

	isClientStreaming := method.Desc.IsStreamingClient()
	isServerStreaming := method.Desc.IsStreamingServer()

	// Generate method signature based on streaming type
	var signature string

	switch {
	case !isClientStreaming && !isServerStreaming:
		// Unary
		signature = fmt.Sprintf("\t%s(ctx context.Context, in *%s) (*%s, error)",
			methodName, inputType, outputType)
	case isClientStreaming && !isServerStreaming:
		// Client streaming
		signature = fmt.Sprintf("\t%s(ctx context.Context, in chan *%s) (*%s, error)",
			methodName, inputType, outputType)
	case !isClientStreaming && isServerStreaming:
		// Server streaming
		signature = fmt.Sprintf("\t%s(ctx context.Context, in *%s, out chan *%s) error",
			methodName, inputType, outputType)
	case isClientStreaming && isServerStreaming:
		// Bidirectional streaming
		signature = fmt.Sprintf("\t%s(ctx context.Context, in chan *%s, out chan *%s) error",
			methodName, inputType, outputType)
	}

	buf.WriteString(fmt.Sprintf("%s\n", signature))
}

func (g *generator) generateRegistrationFunction(buf *strings.Builder, serviceName string) {
	buf.WriteString(fmt.Sprintf("// Register%sServer registers a %sServer with the JSON-RPC service registry.\n", serviceName, serviceName))
	buf.WriteString("// It returns a *jrpc.Service that can be used to handle JSON-RPC requests.\n")
	buf.WriteString(fmt.Sprintf("func Register%sServer(server %sServer) *jrpc.Service {\n", serviceName, serviceName))
	buf.WriteString("\treturn jrpc.Register(server)\n")
	buf.WriteString("}\n\n")

	// Add compile-time interface check
	buf.WriteString(fmt.Sprintf("// Ensure Unimplemented%sServer implements %sServer\n", serviceName, serviceName))
	buf.WriteString(fmt.Sprintf("var _ %sServer = (*Unimplemented%sServer)(nil)\n\n", serviceName, serviceName))
}
